// import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
// import { InjectRepository } from '@nestjs/typeorm';
// import { Repository, Between } from 'typeorm';
// import { Cron, CronExpression } from '@nestjs/schedule';
// import { Telegraf } from 'telegraf';
// import { Student } from '../../core/entity/student.entity';
// import { Lesson } from '../../core/entity/lesson.entity';
// import { config } from 'src/config';

// @Injectable()
// export class NotificationService implements OnModuleInit {
//   private bot: Telegraf;
//   private readonly logger = new Logger(NotificationService.name);

//   constructor(
//     @InjectRepository(Lesson)
//     private readonly lessonRepo: Repository<Lesson>,
//   ) {}

//   async onModuleInit() {
//     try {
//       this.bot = new Telegraf(config.TELEGRAM_BOT_TOKEN);
//       this.logger.log('Telegram bot initialized');
//     } catch (error) {
//       this.logger.error('Telegram bot initialization error:', error.message);
//     }
//   }

//   @Cron(CronExpression.EVERY_5_MINUTES)
//   async handleLessonReminders() {
//     this.logger.log('Dars eslatmalarini tekshirish boshlandi...');

//     const now = new Date();
//     const in15Minutes = new Date(now.getTime() + 15 * 60000);
//     const in25Minutes = new Date(now.getTime() + 25 * 60000);

//     const upcomingLessons = await this.lessonRepo.find({
//       where: {
//         startTime: Between(in15Minutes, in25Minutes),
//       } as any,
//       relations: ['student'],
//     });

//     for (const lesson of upcomingLessons) {
//       const participants = (lesson as any).students || (lesson as any).student;

//       if (participants && participants.length > 0) {
//         for (const student of participants) {
//           await this.sendTelegramReminder(student, lesson);
//         }
//       }
//     }
//   }

//   private async sendTelegramReminder(student: Student, lesson: Lesson) {
//     if (!student.tgId || student.isBlocked) return;

//     const timeString = lesson.startTime.toLocaleTimeString('uz-UZ', {
//       hour: '2-digit',
//       minute: '2-digit',
//     });

//     const message =
//       `üîî *Dars eslatmasi!*\n\n` +
//       `üìö *Fan:* ${(lesson as any).name || 'Dars'}\n` +
//       `‚è∞ *Vaqt:* ${timeString}\n` +
//       `üìç *Joy:* ${(lesson as any).room || 'Onlayn'}\n\n` +
//       `Iltimos, darsga kechikmasdan kiring!`;

//     try {
//       if (!this.bot) {
//         this.logger.warn('Bot not initialized, skipping message');
//         return;
//       }

//       await this.bot.telegram.sendMessage(student.tgId, message, {
//         parse_mode: 'Markdown',
//       });
//       this.logger.log(
//         `Eslatma yuborildi: Student ID ${student.id} (TG: ${student.tgId})`,
//       );
//     } catch (error) {
//       this.logger.error(
//         `Telegram xabar yuborishda xatolik (Student: ${student.id}):`,
//         error.message,
//       );
//     }
//   }
// }


import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between } from 'typeorm';
import { Cron, CronExpression } from '@nestjs/schedule';
import { Telegraf } from 'telegraf';
import { Student } from '../../core/entity/student.entity'; // Importlarni tekshiring
import { Lesson } from '../../core/entity/lesson.entity';   // Importlarni tekshiring
import { config } from 'src/config';

@Injectable()
export class NotificationService implements OnModuleInit {
  private bot: Telegraf;
  private readonly logger = new Logger(NotificationService.name);

  constructor(
    @InjectRepository(Lesson)
    private readonly lessonRepo: Repository<Lesson>,
  ) {}

  async onModuleInit() {
    try {
      if (!config.TELEGRAM_BOT_TOKEN) {
        throw new Error('TELEGRAM_BOT_TOKEN topilmadi! .env faylni tekshiring.');
      }
      this.bot = new Telegraf(config.TELEGRAM_BOT_TOKEN);
      this.logger.log('‚úÖ Telegram bot initialized');
    } catch (error) {
      this.logger.error('‚ùå Telegram bot initialization error:', error.message);
    }
  }

  // Debug uchun har daqiqada ishlaydi (Keyin EVERY_5_MINUTES ga qaytaramiz)
  @Cron(CronExpression.EVERY_5_MINUTES)
  async handleLessonReminders() {
    const now = new Date();
    
    // 15 va 25 daqiqa oralig'idagi darslarni qidiramiz
    // Masalan: Hozir 13:00 bo'lsa, 13:15 va 13:25 orasidagi darslar
    const startWindow = new Date(now.getTime() - 5  * 60000);
    const endWindow = new Date(now.getTime() + 25 * 60000);

    this.logger.log('=============================================');
    this.logger.log(`‚è∞ Hozirgi vaqt (Server): ${now.toString()}`);
    this.logger.log(`üîé Qidirilayotgan oraliq: ${startWindow.getHours()}:${startWindow.getMinutes()} dan ${endWindow.getHours()}:${endWindow.getMinutes()} gacha`);

    try {
      const upcomingLessons = await this.lessonRepo.find({
        where: {
          startTime: Between(startWindow, endWindow),
        },
        relations: ['student'], // Student ma'lumotlari kerak
      });

      this.logger.log(`üìä Oraliqqa tushgan darslar soni: ${upcomingLessons.length}`);

      // DEBUG: Agar dars topilmasa, yaqin 2 soatdagi darslarni chiqarib ko'ramiz
      // Bu vaqt farqini (Timezone) aniqlashga yordam beradi
      if (upcomingLessons.length === 0) {
        this.logger.warn('‚ö†Ô∏è Oraliqda dars topilmadi. Bazadagi yaqin 2 soatlik darslarni tekshiramiz...');
        
        const next2Hours = new Date(now.getTime() + 120 * 60000); 
        const allUpcoming = await this.lessonRepo.find({
          where: {
            startTime: Between(now, next2Hours), 
          },
          order: { startTime: 'ASC' },
          take: 3,
        });

        if (allUpcoming.length > 0) {
          this.logger.log('üí° Bazada quyidagi darslar mavjud (Vaqtni solishtiring!):');
          allUpcoming.forEach(l => {
            this.logger.log(` - Dars: "${l.name}" | Vaqti: ${l.startTime} | (JS Date: ${new Date(l.startTime).toString()})`);
          });
        } else {
          this.logger.error('‚ùå Bazada yaqin 2 soat ichida umuman dars yoq! Yangi dars yarating.');
        }
      }

      // Topilgan darslarga xabar yuborish
      for (const lesson of upcomingLessons) {
        // ManyToOne bo'lgani uchun lesson.student bitta obyekt
        const student = lesson.student;

        if (!student) {
          this.logger.warn(`‚ö†Ô∏è Dars ID: ${lesson.id} uchun student biriktirilmagan.`);
          continue;
        }

        await this.sendTelegramReminder(student, lesson);
      }

    } catch (error) {
      this.logger.error('‚ùå Darslarni qidirishda xatolik:', error.message);
    }
    
    this.logger.log('=============================================');
  }

  private async sendTelegramReminder(student: Student, lesson: Lesson) {
    if (!student.tgId) {
      this.logger.warn(`‚ö†Ô∏è Student (ID: ${student.id}) da Telegram ID yo'q.`);
      return;
    }

    const dateObj = new Date(lesson.startTime);
    const timeString = dateObj.toLocaleTimeString('uz-UZ', {
      hour: '2-digit',
      minute: '2-digit',
      timeZone: 'Asia/Tashkent',
    });

    const message =
      `üîî *Dars eslatmasi!*\n\n` +
      `üìö *Fan:* ${lesson.name || 'Dars'}\n` +
      `‚è∞ *Vaqt:* ${timeString}\n` +
      `üìç *Link:* ${lesson.googleMeetUrl || 'Onlayn'}\n\n` +
      `Iltimos, darsga kechikmasdan kiring!`;

    try {
      if (!this.bot) {
        this.logger.error('‚ùå Bot initialized emas.');
        return;
      }

      await this.bot.telegram.sendMessage(student.tgId, message, {
        parse_mode: 'Markdown',
      });
      this.logger.log(
        `‚úÖ Xabar yuborildi: ${student.id || 'Student'} (TG: ${student.tgId})`,
      );
    } catch (error) {
      this.logger.error(
        `‚ùå Telegram xabar yuborishda xatolik (TG ID: ${student.tgId}): ${error.message}`,
      );
    }
  }
}